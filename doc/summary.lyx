#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{fullpage}
%\usepackage{framed}
\usepackage{listings}
%\usepackage{fix-cm}

% bold ttfonts
\usepackage{courier}
\renewcommand{\ttdefault}{pcr}

\lstset{%
language=C, 
numbers=left, 
frame=single, 
xleftmargin=20pt, 
xrightmargin=40pt, 
basicstyle=\ttfamily \small, 
tabsize=2 %
}

\newenvironment{boa}
{% This is the begin code
  \begin{minipage}[t]{0.9\columnwidth}%
  %  \begin{framed}
  \footnotesize 
  \ttfamily    
}
{% This is the end code
  %  \end{framed}
  \end{minipage}
\medskip{}
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\backslash
fontsize{40}{40}
\backslash
selectfont 
\backslash
bfseries boa}
\backslash

\backslash

\end_layout

\end_inset

 
\begin_inset VSpace bigskip
\end_inset


\begin_inset Graphics
	filename ../boa.png
	lyxscale 33
	height 50pt

\end_inset


\series bold
\size giant

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\series default
\size default

\begin_inset VSpace bigskip
\end_inset

Buffer Overrun Analyzer
\end_layout

\begin_layout Author
Edo Cohen
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
 039374814 
\backslash

\backslash
 sedoc@t2 
\backslash
and 
\end_layout

\end_inset

Tzafrir Rehan
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
 039811880 
\backslash

\backslash
 tzafrir@cs 
\backslash
and 
\end_layout

\end_inset

Gai Shaked
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
 036567055 
\backslash

\backslash
 gai@tx
\end_layout

\end_inset


\end_layout

\begin_layout Date

\size larger
\begin_inset VSpace 5pheight%
\end_inset

Project in advanced programming - program analysis (236503)
\begin_inset Newline newline
\end_inset


\size default

\begin_inset VSpace medskip
\end_inset

Computer Science Department, Technion - Israel Institute of Technology
\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
The C programming language is riddled with security vulnerablitilies, the
 most prominent of which is the risk of buffer overruns.
 Programs written in C are widely used today, many of them with legacy code.
 There are two possible methods to try and detect buffer overruns - static
 and dynamic analysis.
\end_layout

\begin_layout Standard
Dynamic analysis attempts to intercept access outside the bounds of an array
 during runtime.
 While this can be effective with the use of rigorous testing with high
 coverage to discover potential overruns, this method does not supply a
 sound analysis, and some buffer overruns may be undetected.
 In addition, runtime checking of array boundaries may be used to prevent
 buffer overruns, but incurs a performance cost.
\end_layout

\begin_layout Standard
Static analysis attempts to detect overruns by analyzing the source code.
 This does not require any changes to the code or runtime environment, and
 can be implemented soundly (no false negatives).
 However, a precise analysis is not scalable, and some simplifications must
 be made, at the cost of possible false positives (false overrun indication).
 
\end_layout

\begin_layout Section
Goal
\end_layout

\begin_layout Standard
Implement a static buffer overrun analyzer for the C programming language.
 The tool must conform to the following requirements:
\end_layout

\begin_layout Itemize
Provide analysis over any valid
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We define 
\size normal
\emph on
Valid C
\emph default
 code as any code that is compiled by 
\emph on
gcc
\emph default
 with the 
\emph on
-Wall
\emph default
 flag without any warnings.
\end_layout

\end_inset

 C code as is, without requiring the programmer to provide any meta information.
\end_layout

\begin_layout Itemize
Provide 
\emph on
Soundness
\emph default
: Report 100% of the buffer overruns in the code, with no 
\emph on
False Negatives
\emph default
 reported.
\end_layout

\begin_layout Itemize
Provide output in a machine readable format that is also easily readable
 by humans.
\end_layout

\begin_layout Itemize
Minimize false positives.
\end_layout

\begin_layout Section
Assumptions
\end_layout

\begin_layout Standard
In order to achieve these requirements we also defined several assumptions
 on the input code:
\end_layout

\begin_layout Itemize
The programmer knows that the C string library requires that a string must
 end with the NULL terminating character '
\backslash
0', and will never mutate the last byte of a buffer in a way that will cause
 an overrun.
\end_layout

\begin_layout Itemize
The programmer never uses an uninitialized value.
\end_layout

\begin_layout Chapter
Boa
\begin_inset CommandInset label
LatexCommand label
name "chap:boa"

\end_inset


\end_layout

\begin_layout Section
Tool Overview
\end_layout

\begin_layout Standard
Boa is designed as a series of modular components.
 Each component receives input from the previous component, and passes on
 its analysis to the next one.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename sequence.png
	width 52text%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Main components and stages
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
A C compilation module is compiled using the Clang open-source compiler.
 Clang outputs LLVM bitcode, which provides the benefits of SSA (Single
 Static Assignment) and a manageable intruction set.
\end_layout

\begin_layout Itemize
The constraint generator performs a single LLVM pass over the bitcode.
 During this pass, program statements are translated into linear constraints
 over constraint variables (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Constraint-Generator"

\end_inset

).
 In addition, the constraint generator collects a set of the buffers in
 the code, for use by the following components.
\end_layout

\begin_layout Itemize
The linear solver performs
\emph on
 taint analysis
\emph default
 on the set of constraints, removing any illegal constraints (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Handling-infeasible-problems"

\end_inset

).
 Then the constraints are solved, and buffers with potential overruns are
 reported.
\end_layout

\begin_layout Itemize
The linear solver also offers a blame system (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Blame-system"

\end_inset

), through which reported overruns may be root-caused.
 By reporting the set of statements which caused the overrun to be reported,
 the report may be validated as a possible overrun, or dismissed as a false
 positive.
\end_layout

\begin_layout Standard
The following sections expand on the different components in the boa framework.
\end_layout

\begin_layout Section
Constraint Generator
\begin_inset CommandInset label
LatexCommand label
name "sec:Constraint-Generator"

\end_inset


\end_layout

\begin_layout Standard
Constraint generation is the process whereby LLVM operations are translated
 into a set of linear constraints.
 Constraint generation is performed in a flow-insensitive manner - meaning
 that the order of statements is not reflected in the constraints.
 This approach has several limitations, some as elementary as handling the
 statement '
\family typewriter
i++
\family default
' (this is elaborated in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Constraint-Generator"

\end_inset

).
 Unfortunately, flow sensitivity does not scale well on even medium-sized
 programs.
 Some limitations of flow insensitivity are alieviated by LLVM's inherent
 SSA (Single Static Assignment) representation.
\end_layout

\begin_layout Standard
Boa applies a limited form of context sensitivity.
 String manipulation functions from the 
\family typewriter
string.h
\family default
 and 
\family typewriter
stdio.h
\family default
 libraries are individually modeled according to their effects on parameters
 and return value.
 User functions are modeled in a constext-insensitive manner - constraints
 for the function body are generated once for the formal parameters.
 On encountering a function call, Boa generates constraints between the
 actual parameters and the formal parameters.
\end_layout

\begin_layout Standard
Constraints are generated based on the approach outlined in 
\begin_inset CommandInset citation
LatexCommand cite
key "Ganapathy:2003:BOD:948109.948155,citeulike:514510"

\end_inset

, with a few differences.
 Each integer '
\family typewriter
i
\family default
' is modeled using a single pair of constraint variables '
\family typewriter
i!max
\family default
' and '
\family typewriter
i!min
\family default
', denoting the possible range of values for it.
 Each buffer '
\family typewriter
buf
\family default
' is modeled using 3 pairs of linear constraint variables: '
\family typewriter
buf!alloc!min
\family default
' and '
\family typewriter
buf!alloc!max
\family default
' - which denote the possible range for the buffer's allocated size;  '
\family typewriter
buf!read!min
\family default
' and '
\family typewriter
buf!read!max
\family default
' - which denote the possible range for read operations from the buffer;
 '
\family typewriter
buf!write!min
\family default
' and '
\family typewriter
buf!write!max
\family default
' - which denote the possible range for write operations to the buffer.
 Read and write operations must be modeled separately, to avoid adding implicit
 constraints between buffers (elaborated in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Buffer-aliasing"

\end_inset

).
\end_layout

\begin_layout Standard
A fourth constraint variable pair, '
\family typewriter
buf!used!min
\family default
' and '
\family typewriter
buf!used!max
\family default
', is added for each buffer before passing the constraints to the linear
 solver.
 These variables are added with the following constraints:
\begin_inset Formula 
\[
\left\{ \mathbf{\mbox{buf!write!max}}\right\} \le\left\{ \mathbf{\mbox{buf!used!max}}\right\} \le\left\{ \mathbf{\mbox{buf!read!max}}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left\{ \mathbf{\mbox{buf!write!min}}\right\} \ge\mathbf{\left\{ \mbox{buf!used!min}\right\} }\ge\left\{ \mathbf{\mbox{buf!read!min}}\right\} 
\]

\end_inset

This creates a simple variable denoting the possible range of access to
 the buffer.
\end_layout

\begin_layout Standard
The next sections describe the constraints generated for the different statement
s.
\end_layout

\begin_layout Subsection
Integers 
\end_layout

\begin_layout Standard
Integer assignments generate constraints on their values.
 Consider the C-statement
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption=integer assignment]
\end_layout

\begin_layout Plain Layout

int i = 12;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

The constraint generated from this assignment should reflect that i is in
 the range containing 
\begin_inset Formula $\left[12,12\right]$
\end_inset

.
 Therefore, the constraints '
\begin_inset Formula $\left\{ \mbox{i!max}\right\} \ge12$
\end_inset

', '
\begin_inset Formula $\left\{ \mathbf{\mbox{i!min}}\right\} \le12$
\end_inset

' are generated and added to the constraint problem.
\end_layout

\begin_layout Standard
However, this case is a simple one.
 Consider the following code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption=integer manipulation]
\end_layout

\begin_layout Plain Layout

int a = 10, b = 20;
\end_layout

\begin_layout Plain Layout

int sum, prod, quotient;
\end_layout

\begin_layout Plain Layout

sum = a + b;
\end_layout

\begin_layout Plain Layout

prod = -3 * sum;
\end_layout

\begin_layout Plain Layout

quotient = 2 / a;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

The constraints generated for '
\family typewriter
sum
\family default
' are still relatively simple: 
\begin_inset Formula 
\[
\left\{ \mbox{sum!max}\right\} \ge\left\{ \mbox{a!max}\right\} +\left\{ \mbox{b!max}\right\} 
\]

\end_inset


\begin_inset Formula 
\[
\left\{ \mbox{sum!min}\right\} \le\left\{ \mbox{a!min}\right\} +\left\{ \mbox{b!min}\right\} 
\]

\end_inset

Note that the range for sum is not immediately apparent, but is dependent
 on the value of two other constraint variables.
 The constraints generated for 'prod' are not as simple, since a negative
 factor flips the min and max values.
 Also, any multiplication between two variables or division by a variable
 results in a non-linear constraint, which our linear solver is incapable
 of handling.
 Therefore, results of such operations are considered unbounded, and the
 constraints generated are:
\begin_inset Formula 
\[
\left\{ \mbox{quotient!min}\right\} \le-\infty
\]

\end_inset


\begin_inset Formula 
\[
\left\{ \mbox{quotient!max}\right\} \ge\infty
\]

\end_inset


\end_layout

\begin_layout Subsection
Array Allocation 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=4,lastline=6,caption=static array allocation]{../tests/t
estcases/simple3.c}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=6,lastline=9,caption=dynamic array allocation]{../tests/
testcases/dynMem2.c}
\end_layout

\end_inset

Array declarations such as the above supply the 
\emph on
alloc
\emph default
 value for arrays.
 Arrays may be statically or dynamically allocated - in both cases the treatment
 is similar.
 The code in the examples above would generate the following constraints:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{buf!alloc!max}\right\}  & \ge & 10\\
\left\{ \mbox{buf!alloc!min}\right\}  & \le & 10
\end{eqnarray*}

\end_inset

for the buffer '
\family typewriter
buf
\family default
', and:
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{dynamic!alloc!max}\right\}  & \ge & \left\{ \mbox{i!max}\right\} \\
\left\{ \mbox{dynamic!alloc!min}\right\}  & \le & \left\{ \mbox{i!min}\right\} 
\end{eqnarray*}

\end_inset

for the return value of the 
\family typewriter
malloc()
\family default
 call.
\end_layout

\begin_layout Standard
In the case of 
\family typewriter
malloc()
\family default
 calls, the parameter may be a complex int expression, this is handled as
 far as possible for linear constraints - see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Linear-Solver"

\end_inset

.
\end_layout

\begin_layout Subsection
Buffer Aliasing
\begin_inset CommandInset label
LatexCommand label
name "sub:Buffer-aliasing"

\end_inset


\end_layout

\begin_layout Standard
Certain statements may result in a buffer alias.
 This occurs when a pointer is set to point to another pointer or buffer,
 possibly with an offset (i.e.
 
\family typewriter
p = buf
\family default
 or 
\family typewriter
p = buf + 10
\family default
).
\end_layout

\begin_layout Standard
The direct approach towards modeling this aliasing as a linear constraint
 is to define a single set of constraint variables for each buffer or pointer
 - 
\family typewriter
buf!used!max
\family default
 and
\family typewriter
 buf!used!min
\family default
. However, this simple modeling creates an unwanted side-effect in solving
 a linear-inequality system.
 Consider the following code: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=4,lastline=7,caption=array aliasing]{../tests/testcases/
aliasing3.c}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

  The pointer 
\family typewriter
p
\family default
 is aliased to the array  
\family typewriter
buf
\family default
.
 This aliasing should be modeled so that the call to 
\family typewriter
strlen
\family default
 returns the widest (most conservative) possible bounds of access to 
\family typewriter
p
\family default
, which is at least as wide as the bounds of 
\family typewriter
buf
\family default
.
 Therefore the following constraints must be generated: 
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{p!used!max}\right\}  & \ge & \left\{ \mbox{buf!used!max}\right\}\\
\left\{ \mbox{p!used!min}\right\}  & \le & \left\{ \mbox{buf!used!min}\right\}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
However, the write into 
\family typewriter
p[20]
\family default
 should be treated as a (possible) write into 
\family typewriter
buf[20]
\family default
, resulting in the following constraints: 
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{buf!used!max}\right\}  & \ge & \left\{ \mbox{p!used!max}\right\}\\
\left\{ \mbox{buf!used!min}\right\}  & \le & \left\{ \mbox{p!used!min}\right\}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
This combined set of constraints implies an even stronger constraint between
 the two variables - they are forced to be equal, meaning 
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{buf!used!max}\right\}  & = & \left\{ \mbox{p!used!max}\right\}\\
\left\{ \mbox{buf!used!min}\right\}  & = & \left\{ \mbox{p!used!min}\right\}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Now consider a common case where the pointer 
\family typewriter
p
\family default
 points to several different buffers in different contexts.
 These simplistic constraints demand  that all buffers are equal through
 transitivity.
 Obviously, this is not good enough.
\end_layout

\begin_layout Standard
Instead, as mentioned in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Constraint-Generator"

\end_inset

, buffers and pointers are modeled using two separate sets of constraint
 variables,  
\family typewriter
buf!read!max
\family default
, 
\family typewriter
buf!read!min
\family default
 and 
\family typewriter
buf!write!max
\family default
, 
\family typewriter
buf!write!min
\family default
.
 By trreating read and write operations on buffers separately, this problem
 can be eliminated.
 An aliasing is translated into the following constraints:
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{p!read!max}\right\}  & \ge & \left\{ \mbox{buf!read!max}\right\} \\
\left\{ \mbox{p!read!min}\right\}  & \le & \left\{ \mbox{buf!read!min}\right\} \\
\left\{ \mbox{p!write!max}\right\}  & \le & \left\{ \mbox{buf!write!max}\right\} \\
\left\{ \mbox{p!write!min}\right\}  & \ge & \left\{ \mbox{buf!write!min}\right\} 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
The constraints on the read variables ensure that reads on 
\family typewriter
p
\family default
 will return the largest possible range of access performed on 
\family typewriter
buf
\family default
.
 The constraints on the write variables ensure that writes to 
\family typewriter
p
\family default
 will always be be reflected in 
\family typewriter
buf!write
\family default
.
\end_layout

\begin_layout Standard
Finally, whenever a buffer is added to the constraint problem, the constraints
 to link the two  sets are added.
 These are added only for the buffers themselves: 
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{buf!read!max}\right\}  & \ge & \left\{ \mbox{buf!used!max}\right\} \ge\left\{ \mbox{buf!write!max}\right\} \\
\left\{ \mbox{p!read!min}\right\}  & \le & \left\{ \mbox{buf!used!min}\right\} \le\left\{ \mbox{buf!write!min}\right\} 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
This method of alias handling also provides a conservative flow-insensitive
 pointer analysis for first-order pointers, by capturing all possible pointer
 assignments.
\end_layout

\begin_layout Subsection
Direct array access
\end_layout

\begin_layout Standard
Arrays are manipulated in code in several fashions, the simplest of which
 is direct access by index.
 Consider the statement: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption=direct access]
\end_layout

\begin_layout Plain Layout

buf[10] = 'a';
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

The resulting constraints render down to the expected:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{buf!write!max}\right\}  & \ge & 10\\
\left\{ \mbox{buf!write!min}\right\}  & \le & 10
\end{eqnarray*}

\end_inset

The constraint generator treats the value stored into 
\family typewriter
buf
\family default
 as any other integer assignment, as described above.
\end_layout

\begin_layout Subsection
Functions
\end_layout

\begin_layout Standard
Buffers are often manipulated through function calls, as parameter or return
 value.
 The constrain generator distinguishes between three different types of
 functions, and each is handled differently.
\end_layout

\begin_layout Subsubsection
Functions With Definition
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption=user functions]
\end_layout

\begin_layout Plain Layout

int foo(char *p, int x) {
\end_layout

\begin_layout Plain Layout

 // Do something with p and x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main() {
\end_layout

\begin_layout Plain Layout

 char buf[10];
\end_layout

\begin_layout Plain Layout

 int res = foo(buf, 10);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

These are functions with the definition available for analysis, usually
 functions that are defined in the same compilation unit.
 The constraint generator analyzes these functions in its single llvm pass,
 and generates constraints which may include its formal parameters and return
 value.
 In the example above, the constraints would contain 
\family typewriter
p
\family default
 and 
\family typewriter
x
\family default
, with possible constraints on the int return value.
\end_layout

\begin_layout Standard
Whenever a call to such a function is encountered, the actual parameters
 are constricted to the formal parameters.
 In the example above, the call to 
\family typewriter
foo()
\family default
 would result in 
\family typewriter
p
\family default
 being aliased to 
\family typewriter
buf
\family default
 (as described above), and the constraints 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{x!max}\right\}  & \ge & 10\\
\left\{ \mbox{x!min}\right\}  & \le & 10
\end{eqnarray*}

\end_inset

In addition, 
\family typewriter
res
\family default
 is constrained to the return value, resulting in 
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{res!max}\right\}  & \ge & \left\{ \mbox{foo!max}\right\} \\
\left\{ \mbox{res!min}\right\}  & \le & \left\{ \mbox{foo!min}\right\} 
\end{eqnarray*}

\end_inset

This flow-insensitive analysis is conservative, but may result in false
 buffer overrun warnings.
 It is possible to add some context sensitivity to this analysis by creating
 a separate instance of the formal parameters for every function call, and
 duplicating the constraints for them.
 Previous work 
\begin_inset CommandInset citation
LatexCommand cite
key "Ganapathy:2003:BOD:948109.948155"

\end_inset

 has attempted this and discovered a small reduction in false positives,
 at the price of inflating the constraint problem, impacting performance.
\end_layout

\begin_layout Subsubsection
Known Library Functions
\end_layout

\begin_layout Standard
Some functions do not have a definition supplied, but are so frequently
 used that they must be analyzed.
 The constraint generator contains a bank of commonly used library functions
 which manipulate buffers, and models their effect upon their parameters
 and return value.
 For example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=4,lastline=7,caption=library functions]{../tests/testcas
es/string1.c}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The function strcpy copies its second parameter into the first parameter.
 Thus, for the example above the following constraints are created:
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{buf1!write!max}\right\}  & \ge & \left\{ \mbox{str1!read!max}\right\} \\
\left\{ \mbox{buf1!write!min}\right\}  & \le & \left\{ \mbox{str1!read!min}\right\} \\
\left\{ \mbox{buf2!write!max}\right\}  & \ge & \left\{ \mbox{str2!read!max}\right\} \\
\left\{ \mbox{buf2!write!min}\right\}  & \le & \left\{ \mbox{str2!read!min}\right\} 
\end{eqnarray*}

\end_inset

The functions which are modeled are mostly from 
\family typewriter
string.h
\family default
 and 
\family typewriter
stdio.h
\family default
 with several others (
\family typewriter
malloc
\family default
 for example).
 This is performed in a conservative manner, meaning the worst case scenario
 is always assumed.
\end_layout

\begin_layout Subsubsection
Unknown Functions
\end_layout

\begin_layout Standard
Some functions called are neither of the two above cases.
 For these functions, the constraint generator cannot assume anything about
 the body of the function.
 In order for analysis to be conservative, all buffer parameters are considered
 to be accessed outside of bounds, and any int return value is considered
 unbounded.
\end_layout

\begin_layout Standard
This is not as great a problem as it may appear.
 The vast majority of string manipulations is performed by user functions
 and 
\family typewriter
string.h
\family default
, 
\family typewriter
stdio.h
\family default
 functions, while the blame system described later on provides a mechanism
 for detecting irrelevant overruns which result from unknown functions.
 
\end_layout

\begin_layout Section
Linear Solver
\begin_inset CommandInset label
LatexCommand label
name "sec:Linear-Solver"

\end_inset


\end_layout

\begin_layout Standard
The constraints generated represent a linear problem, and each solution
 of the problem suggests a set of ranges for the values each integer may
 recieve and the allocation and usage of each buffer.
 As we aim to find the tightest ranges, we direct our linear solver to find
 a solution maximizing -
\begin_inset Formula 
\[
Goal=\sum_{\mathbf{Buffers}}\left[\left\{ \mbox{buf!used!min}\right\} \stackrel{\phantom{+}}{+}\left\{ \mbox{buf!alloc!min}\right\} -\left\{ \mbox{buf!used!max}\right\} -\left\{ \mbox{buf!alloc!max}\right\} \right]
\]

\end_inset

A solution satisfying this goal will maximize the lower bounds and minimize
 the upper bounds of each buffer access, and thus assure we get the tightest
 solution.
\end_layout

\begin_layout Standard
Once we have the solution
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The solution is a set of integer values, one for each of the problem variables,
 such that all the constraints are satisfied and the 
\begin_inset Formula $Goal$
\end_inset

 value is maximized
\end_layout

\end_inset

 we test each buffer to verify that - 
\begin_inset Formula 
\[
\left\{ \mbox{buf!used}\right\} \subseteq\left\{ \mbox{buf!alloc}\right\} 
\]

\end_inset

Which means - 
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{buf!used!max}\right\}  & < & \left\{ \mbox{buf!alloc!min}\right\} \\
\left\{ \mbox{buf!used!min}\right\}  & \ge & 0
\end{eqnarray*}

\end_inset

Note that we stick to the size and numbering conventions of C, safe access
 to a buffer of size 
\begin_inset Formula $n$
\end_inset

 is any access to the cells 
\begin_inset Formula $0\dots n-1$
\end_inset

.
 If the solution does not satisfy one of the constraints, we report a possible
 buffer overrun in this specific buffer.
 
\end_layout

\begin_layout Subsection
Handling infeasible problems
\begin_inset CommandInset label
LatexCommand label
name "sub:Handling-infeasible-problems"

\end_inset


\end_layout

\begin_layout Standard
In many cases, the constraints we generate create an infeasible linear problem.
 The simplest example of such case is - 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[caption=increment]
\end_layout

\begin_layout Plain Layout

int i;
\end_layout

\begin_layout Plain Layout

i++;
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset

The constraints generated from the second line will be - 
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{tmp!max}\right\}  & \ge & \left\{ \mbox{i!max}\right\} +1\\
\left\{ \mbox{i!max}\right\}  & \ge & \left\{ \mbox{tmp!max}\right\} 
\end{eqnarray*}

\end_inset

Which is obviously an infeasible set of constraints.
 The same problem holds in many different cases, including 
\emph on
strcat
\emph default
 (which concatenates one string to the end of another, and therefore implies
 an equivalent set of constraints to the string used length).
\end_layout

\begin_layout Standard
When our linear solver discovers that the constraints problem we have generated
 is infeasible, we wish to make the smallest change to the problem and make
 it feasible once again.
 There is a great body of work in the area of finding and eliminating IIS
 (
\emph on
irreducibly inconsistent system
\emph default
), and we follow the algorithms and terminology of Chinneck and Dravnieks
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:journals/informs/ChinneckD91"

\end_inset

.
 The common and naive approach is the deletion filtering -
\end_layout

\begin_layout Enumerate
input: 
\begin_inset Formula $Q$
\end_inset

 is an infeasible set of constraints
\end_layout

\begin_layout Enumerate
[try to delete] FOREACH 
\begin_inset Formula $q_{i}\in Q$
\end_inset

 DO:
\end_layout

\begin_deeper
\begin_layout Enumerate
Test whether 
\begin_inset Formula $Q\backslash q_{i}$
\end_inset

 is feasible -
\end_layout

\begin_deeper
\begin_layout Enumerate
IF infeasible - set 
\begin_inset Formula $Q=Q\backslash q_{i}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset Formula $Q$
\end_inset

 is an IIS
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
After one iteration the algorithm returns an IIS, which can be removed from
 the original problem.
 In case there are several IISs in the original problem - the algorithm
 should repeat until the problem become feasible.
 We have implemented this approch at first, and it did work well on small
 pieces of code, but naturally did not scale well - on the same testing
 system described in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Results"

\end_inset

 it took more than half an hour to eliminate the IISs in the 400 lines of
 source of 
\emph on
md5
\emph default
 library, and more than 8 hours to find the blames (section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Blame-system"

\end_inset

) as well.
 Therefore we read further and implemented an elastic filter for eliminating
 IIS.
 
\end_layout

\begin_layout Subsubsection
Elastic filter
\end_layout

\begin_layout Standard
The main idea behind elastic filtering is adding a new 
\emph on
elastic variable
\emph default
 to each constraint, allowing it to 
\emph on
strech
\emph default
 and thus make the problem feasible.
 The elastic variable is simply a new variable, which appears on a single
 constraint, and is confined to non-negative values.
 The constraints are of the form - 
\begin_inset Formula 
\[
\sum a_{j}X_{j}\ge c
\]

\end_inset

And with the elastic variable added - 
\begin_inset Formula 
\[
\sum a_{j}X_{j}+e\ge c
\]

\end_inset


\end_layout

\begin_layout Standard
The elastic variable gives the linear solver one more degree of freedom
 for each constraint, and therefore makes it feasible.
 Using the elastic variable (i.e.
 - assigning it a non-zero value) is reffered to as 
\emph on
streching.
 
\emph default
Once the linear system is feasible we can solve the new problem, but instead
 of solving it in order to maximize the original target value, we try to
 minimize the effect of the 
\emph on
elastic variables
\emph default
.
 In this case the problem is feasible - therefore a solution can be found,
 and since we direct the linear solver to minimize the values of the elastic
 variable - each elastic variable assigned a non-zero value marks a constraint
 which is part on an IIS (i.e.
 - if it's elastic variable did not exist the problem was infeasible).
 Formally - 
\end_layout

\begin_layout Enumerate
Initialize 
\begin_inset Formula $S=\emptyset$
\end_inset

 (will hold the IIS)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $Q$
\end_inset

 is an infeasible set of constraints of the form - 
\begin_inset Formula 
\[
q_{i}:\sum_{j=1}^{n_{i}}a_{i_{j}}X_{i_{j}}\ge c_{i}
\]

\end_inset

where 
\begin_inset Formula $a_{i_{j}},c_{i}$
\end_inset

 are constants and 
\begin_inset Formula $X_{i_{j}}$
\end_inset

 is a variable of the constraint problem.
\end_layout

\begin_layout Enumerate
Add an 
\emph on
elastic variable
\emph default
 
\begin_inset Formula $e_{i}$
\end_inset

 to each constraint 
\begin_inset Formula $q_{i}\in Q$
\end_inset

 such that - 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $q_{i}:\sum_{j=1}^{n_{i}}a_{i_{j}}X_{i_{j}}+e_{i}\ge c_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
Limit the elastic variables to accept non-negative values, and set the goal
 of the linear problem to minimize the sum of the elastic variables - 
\begin_inset Formula $Goal=-\sum e_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
WHILE the problem is feasible - 
\end_layout

\begin_deeper
\begin_layout Enumerate
Solve the linear problem, for each elastic variable 
\begin_inset Formula $e_{i}$
\end_inset

 - 
\end_layout

\begin_deeper
\begin_layout Enumerate
If 
\begin_inset Formula $e_{i}>0$
\end_inset

 - 
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $S=S\cup\left\{ q_{i}\right\} $
\end_inset

 
\end_layout

\begin_layout Enumerate
remove 
\begin_inset Formula $e_{i}$
\end_inset

 (
\begin_inset Formula $q_{i}:\sum_{j=1}^{n_{i}}a_{i_{j}}X_{i_{j}}\ge c_{i}$
\end_inset

)
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate
return 
\begin_inset Formula $S$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
The most time-consuming part of the process is trying to solve the constraint
 problem (the linear solver uses Simplex).
 The delete filter tries to solve 
\begin_inset Formula $n$
\end_inset

 problems (
\begin_inset Formula $n$
\end_inset

 - the number of constraints in the original problem) and return one IIS.
 On the other hand - the elastic filter perform only 
\begin_inset Formula $m$
\end_inset

 iterations (
\begin_inset Formula $m$
\end_inset

 - the number of constraints in the smaller IIS in the problem), and return
 
\begin_inset Formula $m$
\end_inset

 constraints of each of the IISs in the problem.
 A typical IIS in the problems generated by our constraint generator consist
 of 3 or 4 constraints, thus we have predicted the performence of the elastic
 filter will be mush better than the deleting filter, and indeed (as we
 describe in detail in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Results"

\end_inset

) the results achived using the elastic filter were much better.
 
\end_layout

\begin_layout Subsubsection
Removing constraints
\end_layout

\begin_layout Standard
Once we located the IIS we aim to remove the problematic constraints - in
 order to make the problem feasible, but without changing much of the semantics
 of the constriants.
 More specifically, we must ensure we do not harm the soundness of our solution,
 removing an IIS must not turn an infeasible problem which was created based
 on a buffer overrun into a feasible problem with no overruns reported.
\end_layout

\begin_layout Standard
In order to preserve the soundness of the solution we take the following
 conservative approach - we remove all of the constraints in the IIS, but
 introduce other constraints instead -
\end_layout

\begin_layout Itemize
For each 
\emph on
max 
\emph default
variable in the removed constraints (e.g.
 
\begin_inset Formula $\left\{ \mbox{buf!used!max}\right\} $
\end_inset

 or 
\begin_inset Formula $\left\{ \mbox{i!max}\right\} $
\end_inset

) we introduce the constraint - 
\begin_inset Formula 
\[
\left\{ \mbox{var!max}\right\} \ge\infty
\]

\end_inset


\end_layout

\begin_layout Itemize
For each 
\emph on
min
\emph default
 variable, we introduce - 
\begin_inset Formula 
\[
\left\{ \mbox{var!min}\right\} \le-\infty
\]

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
These constraints ensure that all of the variables which appear in the IIS
 accept their worst case values, thus conserving the soundness of the problem.
 This approch is not as aggresive as it may appear on first glance, since
 most of the infeasibilities Boa encounters are indeed caused by the incrementin
g operator (or similar cases such as 
\emph on
strcat
\emph default
).
 These kind of statements, in flow insensitive analysis, mean that the value
 (of an integer) or length (of a string) goes to infinity - since we can
 not tell how many times, and under what conditions the command will be
 executed.
\end_layout

\begin_layout Section
Blame system
\begin_inset CommandInset label
LatexCommand label
name "sub:Blame-system"

\end_inset


\end_layout

\begin_layout Standard
In order to make Boa useful we aim not only to inform the programmer about
 possible overruns, but also to direct him into the problematic code, which
 made Boa generate the warning in the first place.
 We call this feature 
\emph on
blame, 
\emph default
since it allows Boa to blame specific operations in specific source lines,
 allowing the programmer to examine each warning quickly and understand
 whether there is a real overrun in the code or the warning is a false alarm.
 
\end_layout

\begin_layout Standard
As far as we know, previous works in this area did not deal with this issue
 (
\begin_inset CommandInset citation
LatexCommand cite
key "citeulike:514510"

\end_inset

) or used a third party tool in order to provide the user with all of the
 code references to the suspect buffer (
\begin_inset CommandInset citation
LatexCommand cite
key "Ganapathy:2003:BOD:948109.948155"

\end_inset

).
 
\end_layout

\begin_layout Standard
The input for our blame system is a list of 
\emph on
unsafe buffers
\emph default
, buffers in which the linear solver detected a possible overrun.
 For each of the unsafe buffers the output is a set of constraints, this
 set should be the minimal necessary set of constraints for the generation
 of the overrun.
 
\end_layout

\begin_layout Standard
Note that the definition of this set resembles the definition of an IIS
 - in both cases we look for a minimal set of constraints which imply a
 global property of the constraints problem.
 Therefore we based our blaming system on reducing the blaming problem to
 the problem of finding an IIS, and then using the existing algorithms to
 find the desired set of constraints.
\end_layout

\begin_layout Standard
The reduction itself simply involves adding two constraints to the problem
 - 
\begin_inset Formula 
\begin{eqnarray*}
\left\{ \mbox{buf!used!max}\right\}  & < & \left\{ \boldsymbol{buf!alloc!min}\right\} \\
\left\{ \mbox{buf!used!min}\right\}  & \ge & 0
\end{eqnarray*}

\end_inset

These are the two constraints we use to ensure that all of the buffer accesses
 are safe, with one different - in this case the left hand expressions are
 constraint variables, and the right hand are values - 
\begin_inset Formula $0$
\end_inset

 in the second constraint and 
\series bold
the value
\series default
 assigned to 
\begin_inset Formula $\left\{ \mbox{buf!alloc!min}\right\} $
\end_inset

 in the first solution of the constraint problem.
 That way the problem becomes infeasible, and removing the infesibility
 will ensure safe only accesses to the buffer left.
\end_layout

\begin_layout Standard
During the constraint generation proccess we add to each constraint a 
\emph on
blame string
\emph default
, which
\emph on
 
\emph default
contains a brief explanation about the nature of the command that caused
 this constraint (e.g.
 
\begin_inset Quotes eld
\end_inset

malloc call
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

add instruction
\begin_inset Quotes erd
\end_inset

 etc) and its source location (source file name and line number).
 Once the elastic filter returns the set of constraints which cause the
 infeasibility (and therefore - cause the overrun) we print the 
\emph on
blame strings
\emph default
 of these constraints.
\end_layout

\begin_layout Subsection
Constraint priorities
\end_layout

\begin_layout Standard
In order to provide the user with the most relevant blame results, we introduce
 three levels of constraints
\end_layout

\begin_layout Description
Structural
\begin_inset space ~
\end_inset

constraints which model the relations between 
\begin_inset Formula $\left\{ \mbox{buf!read}\right\} $
\end_inset

, 
\begin_inset Formula $\left\{ \mbox{buf!used}\right\} $
\end_inset

 and 
\begin_inset Formula $\left\{ \mbox{buf!write}\right\} $
\end_inset

.
 These constraints are part of Boa's internal implementation (disscused
 in detail in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Buffer-aliasing"

\end_inset

), and do not supply the user with information about her possible buffer
 overrun.
\end_layout

\begin_layout Description
Buffer
\begin_inset space ~
\end_inset

aliasing
\begin_inset space ~
\end_inset

constraints disscussed in detail in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Buffer-aliasing"

\end_inset

, which usually do not cause an overrun by themselves, but might be very
 important for the user to understand how writing to a pointer 
\begin_inset Formula $ptr$
\end_inset

 causes an overrun on buffer 
\begin_inset Formula $buf$
\end_inset

.
\end_layout

\begin_layout Description
Normal
\begin_inset space ~
\end_inset

constraints are any other constraints, involving integer arithmetics, library
 function calls etc.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
The cause of the overrun is usually a 
\emph on
normal constraint
\emph default
, while 
\emph on
buffer aliasing
\emph default
 constrains might be vital for the understanding the connection between
 the line where the overrun actually happens and the buffer (decleration)
 itself.
 
\emph on
Structural constraints
\emph default
, on the other hand, will always be part of an IIS, but the are irrelevant
 for the user.
 
\end_layout

\begin_layout Standard
When we run the elstic filter in order to discover the blaming set we first
 allow the elstic filter to choose only 
\emph on
normal constraints
\emph default
, and than run the elastic filter again, allowing it to choose 
\emph on
aliasing constraints
\emph default
 as well.
 That way we ensure that the most relelvant blame results will appear first,
 the aliasing blames will also appear, but the 
\emph on
structural constraints
\emph default
 will not distract the user from the actual problem in her source code.
 A similar approch is taken when we use the elstic filter to turn the initial
 infeasible problem into a feasible problem - in that case we allow the
 elastic filter to remove 
\emph on
normal
\emph default
 or 
\emph on
aliasing
\emph default
 constraints, but not 
\emph on
structural
\emph default
 constrains, since the latter reflect an internal structure we intend to
 keep - and can not be the cause of the overrun.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ClassDiagram.png
	lyxscale 20
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Class diagram
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Boa is realized as a LLVM optimizer plugin, and is compiled into a shared
 object file which is dynamically loaded by 
\emph on
opt
\emph default
, the LLVM optimizer.
\end_layout

\begin_layout Standard
The interface provided by LLVM for our purposes is a use of the 
\emph on
Visitor
\emph default
 design pattern.
 We created a class named 
\emph on
boa
\emph default
 that subclasses LLVM's 
\emph on
ModulePass
\emph default
 class, and implements the method 
\emph on
runOnModule
\emph default
.
 LLVM passes a 
\emph on
Module
\emph default
 (LLVM's representation of a whole program) to this method, which then runs
 Boa's full analysis on the module and exits.
\end_layout

\begin_layout Standard
Almost all of Boa's work is done in the class 
\emph on
ConstraintGenerator
\emph default
.
 This class is responsible for analyzing every code instruction in the module,
 and adding instances of the class 
\emph on
Constraint
\emph default
 to an instance of the class 
\emph on
ConstraintProblem
\emph default
.
\end_layout

\begin_layout Standard
A Constraint instance is a representation of an expression of the form [
\begin_inset Formula $C\geq a_{1}x_{1}+...+a_{n}x_{n}$
\end_inset

] with some attributes such as source code location.
\end_layout

\begin_layout Standard
While analyzing the source code instructions, instances of concrete implementati
ons of the abstract class 
\emph on
VarLiteral
\emph default
 are created.
 The concrete implementations are 
\emph on
Integer, Pointer
\emph default
 and
\emph on
 Buffer
\emph default
, and are used to represent the source code variables modeled by Boa.
\end_layout

\begin_layout Standard
After analyzing all instructions in the program, the method 
\emph on
Solve
\emph default
 of the constraint problem is called, and the solution of the problem is
 analyzed to find buffer overruns, which are then displayed to the user.
\end_layout

\begin_layout Standard
The basic relationships between Boa's classes can be seen in the attached
 class diagram, and more detailed documentation can be found in Boa's doxygen
 documentation
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://boateam.github.com
\end_layout

\end_inset


\end_layout

\end_inset

 and inlined in the code.
\end_layout

\begin_layout Chapter
Development Process
\end_layout

\begin_layout Section
Initial Requirements
\end_layout

\begin_layout Standard
We set out to develop Boa by first defining a preliminary set of requirements,
 and the assumptions required to hold to them.
 These are as specified in the Introduction section.
\end_layout

\begin_layout Section
Research and Technology Survey
\end_layout

\begin_layout Standard
After defining the initial requirements we began researching past work on
 the subject of buffer overrun static analysis, and set out to find which
 tools already exist that can be used to build Boa.
\end_layout

\begin_layout Standard
Our research reached the conclusion of using a linear problem solver, solving
 a set of linear constraints generated from each instruction in the source
 code, in order to find buffer overruns, as described in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:boa"

\end_inset

.
\end_layout

\begin_layout Standard
We set a goal of using only open source tools which are publically available
 for free use under an Open-Source compatible license, and converged towards
 the use of the following tools:
\end_layout

\begin_layout Itemize
GLPK - the GNU Linear Programming Kit
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
GLPK - 
\begin_inset CommandInset href
LatexCommand href
target "http://www.gnu.org/software/glpk/glpk.html"

\end_inset


\end_layout

\end_inset

, available under version 3 of the GNU Public License.
 Used to solve the linear constraints using the Simplex Algorithm.
\end_layout

\begin_layout Itemize
The Clang C Front-End
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Clang C Front-End - 
\begin_inset CommandInset href
LatexCommand href
name "http://clang.llvm.org/"
target "http://clang.llvm.org/"

\end_inset


\end_layout

\end_inset

, available under the University of Illinois/NCSA Open Source License.
 We planned on using Clang's plug-in system in order to go over the code's
 Abstract Syntax Tree and generate linear constraints according to the instructi
ons in the code.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
We then set out to create prototypes.
 First we created example, 
\begin_inset Quotes eld
\end_inset


\emph on
Hello World
\begin_inset Quotes erd
\end_inset


\emph default
 style, programs that make use of Clang and GLPK's interfaces separately,
 and then combined the two prototypes to a single system that works according
 to our system design, produces constraints by traversing the source code,
 solves the constraints system and reports buffer overruns accordingly.
\end_layout

\begin_layout Standard
At this stage we created constraints such that any buffer access and use
 and any function call created an overrun on all buffers involved, and from
 this point on we could work on detecting all buffers in the program and
 reducing false positives.
\end_layout

\begin_layout Section
Test system
\end_layout

\begin_layout Standard
To facilitate the construction of Boa, we worked using 
\emph on
Test Driven Development.
\end_layout

\begin_layout Subsection
Black Box Testing
\end_layout

\begin_layout Standard
Since our entire system is hosted as a Clang plugin, 
\emph on
White Box
\emph default
 testing was not reasonable for our purposes.
\end_layout

\begin_layout Standard
We therefore created a 
\emph on
Black Box
\emph default
 testing system which allowed us to write tests for the full system behaviour.
\end_layout

\begin_layout Standard
A test case is comprised of a source code (.c file) and assertions (.asserts
 file), which define which buffers should be marked as having overruns,
 and which buffers should be marked as safe.
 Buffers may be defined by their name, by their source code location, or
 by both.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[caption=safe.c]{../tests/testcases/safe.c}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[caption=safe.asserts]{../tests/testcases/safe.asserts}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We then wrapped this testing system with scripts that run the tests over
 all available test cases and indicate failure if any test case failed,
 and incorporated this script into our makefile, such that running 
\emph on
make tests
\emph default
 compiles binaries as necessary and runs the tests on the result.
 This allows us to run all our tests after every change in the code, thus
 giving us confidence that old behaviour is not broken, and allowing us
 to start developing a feature by first defining a failing test case, then
 writing code until the test passes.
\end_layout

\begin_layout Standard
We later expanded the testing system to verify the existence and content
 of 
\emph on
Blame
\emph default
 information per a given buffer.
\end_layout

\begin_layout Subsection
Unit Testing
\end_layout

\begin_layout Standard
For those cases where we could generalize common behaviour, we also wrote
 
\emph on
White Box
\emph default
 unit tests.
\end_layout

\begin_layout Standard
We used 
\emph on
Google C++ Testing Framework
\begin_inset Foot
status open

\begin_layout Plain Layout

\emph on
http://code.google.com/p/googletest/
\end_layout

\end_inset


\emph default
 (commonly known as 
\emph on
googletest
\emph default
) as the framework that runs the tests so we could focus on writing the
 tests.
 In some cases we made adjustments to our code so that internal Boa classes
 could be subclassed.
\end_layout

\begin_layout Section
Version Control
\end_layout

\begin_layout Standard
We used 
\emph on
git
\begin_inset Foot
status open

\begin_layout Plain Layout

\emph on
http://git-scm.com/
\end_layout

\end_inset


\emph default
 as our versioning control system.
 We leveraged the distributed nature of git and the cheap branching of git
 to create a workflow based on 
\emph on
feature branches
\emph default
, where each of us worked on a feature on a separate branch of the code
 (usually working on more than one feature at a time), which was later merged
 into our integration branch, 
\emph on

\begin_inset Quotes eld
\end_inset

master
\begin_inset Quotes erd
\end_inset


\emph default
.
\end_layout

\begin_layout Subsection
Online Hosting
\end_layout

\begin_layout Standard
We used Github
\begin_inset Foot
status open

\begin_layout Plain Layout
http://github.com
\end_layout

\end_inset

 as an online code repository.
 This also gave us basic project management tools such as issue tracking
 and code reviews.
\end_layout

\begin_layout Subsection
Code Reviews
\end_layout

\begin_layout Standard
Github allows developers to send each other code reviews (named 
\emph on
Pull Requests
\emph default
 in git terminology).
 We embraced this feature into our work flow such that all of the code that
 goes into 
\emph on
master
\emph default
 has to be reviewed by a team member.
\end_layout

\begin_layout Standard
For each code review, one of the team members which did not write the code
 would read the code and a discussion would start, where the reviewer requested
 improvement to the code, tests or documentation such that the code is correct
 and readable.
 By using this workflow, we ensured that the final code is not only correct,
 but also readable, since each code snippet had to be read by a programmer
 that did not see the code being written before being integrated into 
\emph on
master
\emph default
.
\end_layout

\begin_layout Section
Construction
\end_layout

\begin_layout Standard
During the Construction phase we used the following workflow:
\end_layout

\begin_layout Itemize
Create a local branch which is a copy of 
\emph on
master
\emph default
.
\end_layout

\begin_layout Itemize
Write a failing test case.
\end_layout

\begin_layout Itemize
Write code that handles the failures of the test case, detects all possible
 overruns and does not report a false positive where not needed, until the
 test passes.
\end_layout

\begin_layout Itemize
Upload the branch to the online repository.
\end_layout

\begin_layout Itemize
Send a 
\emph on
Pull Request
\emph default
 to the team.
\end_layout

\begin_layout Itemize
Repeat.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard

\emph on
Git
\emph default
's distributed nature allowed us to use this workflow with minimal overhead
 - On the one hand, orthogonal changes could be developed in parallel, with
 one programmer usually working on more than one change simultaneously in
 different branches.
 On the other hand, when programmer A needed to base his changes on code
 written by programmer B which was not yet reviewed and integrated, he could
 pull the work-in-progress branch from A's repository and base his own work
 without being blocked by the review process.
 
\emph on
Git
\emph default
 also makes it easy to later merge additional changes made by programmer
 B (for example, as a result of the code review process).
\end_layout

\begin_layout Section
Porting To LLVM
\end_layout

\begin_layout Standard
After we developed some initial features such as generating constraints
 according to integer arithmetic instructions, we began seeing some difficulties
 with our use of the Clang front-end as our constraint generation mechanism:
\end_layout

\begin_layout Itemize
The representation of various instructions are scattered across many nodes
 in Clang's representation of the AST, which made it hard to write generalized
 code that handles multiple cases.
\end_layout

\begin_layout Itemize
Clang's 
\emph on
RecursiveASTVisitor
\emph default
 implementation has only been written recently, and as cutting edge code
 it proved to be somewhat uncomfortable to work with.
\begin_inset Note Comment
status open

\begin_layout Plain Layout
TODO(tzafrir): Find examples for this
\end_layout

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Also, working directly on the AST of a high level language meant that the
 space of instructions that Boa needs to handle is quite large.
\end_layout

\begin_layout Standard
We therefore decided it would be best to use the LLVM
\begin_inset Foot
status open

\begin_layout Plain Layout
http://llvm.org/
\end_layout

\end_inset

 (
\emph on
Low Level Virtual Machine
\emph default
) infratructure.
 Boa would first compile the code into LLVM bitcode, and then generate
 constraints according to that bitcode using an 
\emph on
LLVM Pass
\emph default
.
\end_layout

\begin_layout Standard
We first prototyped an LLVM pass in the same manner we prototyped Clang,
 and then rebased Boa to use LLVM instead of clang in its architecture.
 All of our test cases were still valid (and at this stage, failing), so
 we continued our construction cycle, iterating until all existing test
 cases pass, usually using the previously written code as a reference as
 to how to handle a certain instruction (e.g., the constraints generated for
 a multiplication of two integers).
\end_layout

\begin_layout Standard
Within two weeks all our existing test cases passed, and we could refocus
 on further reducing false positives.
\end_layout

\begin_layout Standard
Having specific test cases defining the required handling of specific C
 instructions, a modular design where the mathematical work surrounding
 solving a linear constraint problem is separated from the handling of source
 code instructions, and the encapsulation of our algorithmic code all allowed
 us to very easily handle this major change in our system architecture,
 without having to rewrite the entire system from scratch.
\end_layout

\begin_layout Section
Additional Requirements
\end_layout

\begin_layout Standard
As work on Boa progressed and enough bitcode instructions were properly
 handled, we could begin testing against code snippets from real world code.
 It soon became clear that it is not enough to notify the programmer which
 buffers are overrun, and Boa should also supply the programmer with information
 as to which code-level statements caused the buffer to be overrun.
\end_layout

\begin_layout Standard
Also, we noticed that most of the operations on character buffers in the
 real world are using library functions from 
\emph on
string.h
\emph default
 and 
\emph on
stdio.h
\emph default
, and not direct array access, and that a common cause for buffer overruns
 is the use of 
\emph on
unsafe
\emph default
 library functions which do not use information about the length of the
 buffer, and may cause an overrun.
\end_layout

\begin_layout Standard
We therefore defined the following additional requirements:
\end_layout

\begin_layout Itemize
Provide machine readable 
\emph on
Blame
\emph default
 information which is also easily readable by humans.
\end_layout

\begin_layout Itemize
Model 100% of the functions in 
\emph on
string.h
\emph default
 and 
\emph on
stdio.h
\emph default
 such that all safe accesses will not be marked as unsafe, and all unsafe
 uses of library functions will mark the involved buffers as having overruns.
\end_layout

\begin_layout Itemize
Provide blame information per unsafe library functions such that if an unsafe
 function is used, the blame information will explicitly contain a warning
 against that specific function and will provide the source location of
 the unsafe function call.
\end_layout

\begin_layout Chapter
Results
\begin_inset CommandInset label
LatexCommand label
name "chap:Results"

\end_inset


\end_layout

\begin_layout Standard
We tested Boa on several widespread real world programs.
 We tested to see whether Boa discovers real buffer overruns, and also to
 evaluate the number of false alarms and their main causes.
 The source files used in all of the experiments are availble in Boa git
 repository
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Boa's git repository - 
\begin_inset CommandInset href
LatexCommand href
name "https://github.com/tzafrir/boa"
target "https://github.com/tzafrir/boa"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Performance
\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Performance"

\end_inset

 summarizes the performance of Boa on several programs, the reported running
 times are the results of experiments ran on a Dell Vostro 1310 laptop,
 with Intel Core2 Duo CPU T8100 2.10GHz and 2GB RAM running Debian GNU/Linux
 Wheezy (7.0.0), clang 2.9, llvm 2.9 and GLPK 4.43.
 On this humble configuration Boa can analyze few thousands lines of code
 within seconds, proving that the use of elastic filter did pay off and
 Boa can be used to efficiently analyze any reasonable piece of C code.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fingerd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
md5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
syslog
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ssh
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Source lines
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
230
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
432
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
332
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3483
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Constraints
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
958
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2932
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
894
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3418
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Running time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.308s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.916s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.328s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.348s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Running time (blame)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.604s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.532s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.804s
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8.557s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Buffers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
34
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
94
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Overruns reported
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Real overruns
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Performance"

\end_inset

Boa performance on various real world examples
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Running time
\end_layout

\begin_layout Standard
The main factor affecting Boa's runtime is the number of generated constraints,
 which is proportional to the number of source lines manipulating integers,
 buffers or strings.
 The implementation of md5 is just 100 lines of source code longer than
 syslog, but since almost every line in the cryptographic algorithm of md5
 perform buffer access/manipulation, md5 generates about 4 times the constraints
 of syslog, and this ratio also appear in the running times.
 
\end_layout

\begin_layout Standard
Another important factor is the amount of infeasible constraint sets have
 to be removed, but this measure can hardly be predicted simply by looking
 at the source code.
 When Boa runs the Blame algorithm, another important factor emerges - the
 number of overruns reported, each overrun causing the blame algorithm to
 solve an infeasible problem again, and thus the running time is approximately
 multiplied by the number of overruns detected.
\end_layout

\begin_layout Section
Detailed disscusion
\begin_inset Note Note
status open

\begin_layout Plain Layout
Better name? (Gai)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Over the next sections we will present and describe in details some of the
 possible overruns Boa detected in the programs menthioned above.
 We will use these examples to demonstrate how Boa can be used to detect
 overruns and how one can the blame feature to understand the behaviour
 of Boa and analyze false alarms.
\end_layout

\begin_layout Subsection
fingerd
\end_layout

\begin_layout Standard
We tested Boa using 
\emph on
fingerd
\emph default
, unix finger deamon.
 We altered the current source code to reflect the well known buffer overrun,
 used by the 
\emph on
Internet worm
\emph default
 in 1988.
 The overrun is caused by using the unsafe function 
\emph on
gets
\emph default
 to read data into the 1024
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Back in 1988 
\emph on
line
\emph default
 was 512 bytes, but it does not matter for the analysis.
\end_layout

\end_inset

 bytes buffer 
\emph on
line
\emph default
.
 As far as we know, this is the only real buffer overrun in the 230 lines
 of source code.
\end_layout

\begin_layout Standard
Running on 
\emph on
fingerd
\emph default
 source, Boa reported overruns on 6 out of the 34 buffers.
 Next we present Boa's blame for three of them, and analyze the reason for
 the reported overrun -
\end_layout

\begin_layout Paragraph
line
\end_layout

\begin_layout Standard
is the only real overrun in 
\emph on
fingerd
\emph default
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color red
line
\series default
\color inherit
 tests/realworld/fingerd/fingerd.c:85 
\end_layout

\begin_layout Standard
- 
\series bold
unsafe function call gets
\series default
 [tests/realworld/fingerd/fingerd.c:121]
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias with offset
\series default
 [tests/realworld/fingerd/fingerd.c:121] 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The overrun discovered by Boa, and the real cause reported briefly.
 Note another result of 
\emph on
gets
\emph default
 - every other buffer access based on 
\emph on
line
\emph default
's length will be reported as an overrun.
\end_layout

\begin_layout Paragraph
rhost
\end_layout

\begin_layout Standard
is a char buffer meant to hold the host name
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color red
rhost
\series default
\color inherit
 tests/realworld/fingerd/fingerd.c:86 
\end_layout

\begin_layout Standard
- 
\series bold
unknown function call realhostname_sa
\series default
 [tests/realworld/fingerd/fingerd.c:128]
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias with offset
\series default
 [tests/realworld/fingerd/fingerd.c:128] 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
This false alarm is caused by the use of 
\emph on
realhostname_sa
\emph default
, from 
\emph on
socket.h
\emph default
.
 This false alarm could be avoided if Boa would model 
\emph on
socket.h
\emph default
 functions, but even now the output lets the user identify the cause immediately
 and decide manually whether this call is safe or not.
\begin_inset Note Note
status open

\begin_layout Plain Layout
safe_functions (Gai)
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
malloc
\end_layout

\begin_layout Standard
is a generic name for any buffer created by a malloc call, one can distinguish
 between two malloc calls by their source location (filename and line number)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color red
malloc
\series default
\color inherit
 tests/realworld/fingerd/fingerd.c:141 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias - Phi Node
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias with offset
\series default
 [tests/realworld/fingerd/fingerd.c:149] 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias - Phi Node
\series default

\begin_inset Note Note
status open

\begin_layout Plain Layout
explain phi node? (Gai)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
This blame might seem wierd at a first look, how comes buffer alias alone
 cause an overrun? But the solution appears quickly by looking at the source
 lines (141, 149) reffered by the blame -
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=141,lastline=142, firstnumber=141,caption=fingerd.c]{../t
ests/realworld/fingerd/fingerd.c}
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=149,lastline=151, firstnumber=149]{../tests/realworld/fi
ngerd/fingerd.c}
\end_layout

\end_inset

The programmer allocates a buffer large enough to include 
\emph on
line
\emph default
, and then iterates through the array using the 
\family typewriter
++
\family default
 operator on a pointer.
 Since Boa is a flow-insensitive analyzing tool, we can not assure that
 the inceremental pointer aliasing will be limited to the buffer size -
 and therefore Boa reports a possible buffer overrun.
\begin_inset Note Note
status open

\begin_layout Subsection
flex
\end_layout

\begin_layout Plain Layout
Flex is a well known lexiacal analyzer, we used flex's regexp functions
 code as an another example to a widespread C source code which handles
 buffers.
 Since there was no reported buffer overrun in the source code we have tested,
 we introduced one, replacing - 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=106,lastline=106, firstnumber=106]{../tests/realworld/fl
ex/regex.c}
\end_layout

\begin_layout Plain Layout

With -
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=106,lastline=106, firstnumber=106]{../tests/realworld/fl
ex/regex_unsafe.c}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Running Boa on the altered code results in one false alarm, and a 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
MD5
\end_layout

\begin_layout Standard
Since the early working prototypes of Boa we have tested Boa against 
\emph on
RSA Data Security, Inc.

\emph default
 implementation of
\emph on
 MD5
\emph default
, the a well known cryptographic hash function.
 Since MD5 is a cryptographic algorithm, the implementation consists of
 a lot of bitwise operations on the input string as well as on the predefined
 constant tables.
 Modelling of repeating bitwise operations precisely using linear equations
 is somewhat impossible, therefore Boa takes the safe (sound) side and declares
 buffer accesses based on such operations as unsafe.
 
\end_layout

\begin_layout Standard
Nevertheless, we bring MD5 as an example in order to demonstrate the limitations
 of the linear equations approch for static analysis, and also as an example
 for a code which causes Boa to generate a big amount of constraints per
 source line, and a large number of infeasible constraint sets.
 These challenges caused early prototypes of Boa to run for many hours before
 reporting possible overruns in MD5, while the current version fully analyzes
 and blames MD5's possible overruns within seconds.
\end_layout

\begin_layout Subsection
syslog
\end_layout

\begin_layout Standard
Syslog is a simple application that writes messages into a unix system log,
 and yet another example of a widespread application with a buffer overrun
 vulnerability in its history.
 The syslog vulnerability was first reported on 1995, since syslog is a
 basic unix subroutine - the vulnerability affected not only syslog itself
 but many other applications, including 
\emph on
sendmail
\emph default
, 
\emph on
super
\emph default
 and many other applications.
\end_layout

\begin_layout Standard
The buffer overrun in syslog happens when the log string to be printed is
 longer than 
\emph on
tbuf
\emph default
 (a buffer used by syslog in order to format and print the message), syslog
 calls 
\emph on
vsprintf
\emph default
 in order to write into the buffer, but does not verify that 
\emph on
tbuf
\emph default
 can hold the number of bytes to be copied.
 The solution to the overrun is even more interesting - in order to write
 such messages nevertheless, syslog mentions the buffer overrun - and checks
 the length of the written string after the hazardous call - 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=198,lastline=204, firstnumber=198, caption=syslog.c]{../t
ests/realworld/syslog/syslog.c}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If an overrun have occured, syslog sets the flag 
\emph on
panic
\emph default
 and then after printing the message to the log it will abort instead of
 returning, as the comment briefly explain - 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[firstline=253,lastline=260, firstnumber=253, caption=syslog.c]{../t
ests/realworld/syslog/syslog.c}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When Boa runs on syslog's source code it identifies the possible overrun
 on tbuf, but also reports 7 other possible overruns, all of them seems
 to be false alarms.
 Most of the false alarms happen simply because syslog calls POSIX library
 functions which Boa does not model, for example - 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color red
string literal "127.0.0.1" 
\end_layout

\begin_layout Standard
- 
\series bold
unknown function call inet_addr
\series default
 [tests/realworld/syslog/syslog.c:290] 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias with offset
\end_layout

\begin_layout Standard

\series bold
\color red
string literal "%h %e %T " 
\end_layout

\begin_layout Standard
- 
\series bold
unknown function call strftime
\series default
 [tests/realworld/syslog/syslog.c:160] 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias with offset
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
We have already disscussed this kind of false alarms, and the means to analyze
 and prevent them previously as we disscussed 
\emph on
fingerd
\emph default
.
\end_layout

\begin_layout Subsection
ssh
\end_layout

\begin_layout Standard
Ssh (Secure Shell) is a very common program used to log into another computer
 over a network and to execute commands on a remote machine.
 Here we will present the results reported by Boa upon the major source
 code module of Tatu Yloen's implementation of ssh.
 
\end_layout

\begin_layout Standard
When we first tried to analyze ssh using Boa, we got 41 possible buffer
 overruns reported, out of 94 buffers in the source code.
 Most of these buffers were string literals, which are used as errors, warnings
 or log messages.
 Using the blame feature quickly revealed the reason for this massive amount
 of false alarms - 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color red
string literal "Too many identity files specified (max %d)"
\series default
\color inherit
 
\end_layout

\begin_layout Standard
- 
\series bold
unknown function call fatal
\series default
 [tests/realworld/ssh/ssh.c:362] 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias with offset
\end_layout

\begin_layout Standard

\series bold
\color red
string literal "Using rsh.
 WARNING: Connection will not be encrypted." 
\end_layout

\begin_layout Standard
- 
\series bold
unknown function call log
\series default
 [tests/realworld/ssh/ssh.c:185] 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias with offset
\end_layout

\begin_layout Standard

\series bold
\color red
string literal "setuid: %s" 
\end_layout

\begin_layout Standard
- 
\series bold
unknown function call fatal
\series default
 [tests/realworld/ssh/ssh.c:189] 
\end_layout

\begin_layout Standard
-
\series bold
 buffer alias with offset
\series default
 
\end_layout

\begin_layout Standard

\series bold
\color red
string literal "rsh_connect returned"
\series default
\color inherit
 
\end_layout

\begin_layout Standard
- 
\series bold
unknown function call fatal
\series default
 [tests/realworld/ssh/ssh.c:566] 
\end_layout

\begin_layout Standard
- 
\series bold
unknown function call fatal
\series default
 [tests/realworld/ssh/ssh.c:592] 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias with offset
\end_layout

\begin_layout Standard

\series bold
\color red
string literal "Secure connection to %.100s on port %d refused%s." 
\end_layout

\begin_layout Standard
- 
\series bold
unknown function call log
\series default
 [tests/realworld/ssh/ssh.c:582] 
\end_layout

\begin_layout Standard
- 
\series bold
buffer alias with offset
\series default
 
\end_layout

\begin_layout Standard
...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{boa}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The reason Boa generated these false alarms is simple - this implementation
 of ssh uses four functions for errors, log and debug - 
\emph on
fatal, log, error 
\emph default
and 
\emph on
debug
\emph default
.
 The implementation of these functions is not part of ssh main source module,
 and therefore Boa could not scan the implementation of these functions
 and forced to treat them as unsafe - functions that generate overrun on
 each of the buffers they accept.
\end_layout

\begin_layout Standard
As a solution to this exact problem, Boa provides the 
\emph on
-safe_functions
\emph default
 flag, which allows us to declare specific functions as safe, although the
 source code is not availble to Boa.
 Running Boa with 
\emph on
-safe_functions=log,error,fatal,debug
\emph default
 reduced the number of reported overruns to 17 out of 94.
\end_layout

\begin_layout Standard
Within the remaining 17 buffer overruns, there still are other false alarms
 generated because of ssh functions which are implemented in different modules
 (e.g.
 
\emph on
process_config_line, perror
\emph default
) but each of these functions appears only once or twice, thus locating
 and removing them from Boa's output is equivalent to analyzing any other
 false alarm manually - and therefore we did count these on the table above.
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
We have presented Boa's abilities to analyze decent amount of real, wide
 spread C source code within seconds.
 In all of these cases Boa was able to detect and briefly explain the real
 possible overruns in the source code.
 On the other hand - Boa does suffer from neglectable amount of false alarms,
 which are part of the nature of sound static analysis as a whole, and more
 specifically - the nature of flow- and context-insensitive analysis, and
 the use of integer ranges and other techniques that allows Boa's solution
 to scale well.
\end_layout

\begin_layout Standard
We have also presented several examples to how Boa's blame output can be
 efficiently used to analyze the false alarms, and how repeating false alarms
 which are caused by the same reason (e.g.
 - unknown function) can be easily eliminated.
\end_layout

\begin_layout Standard
We did not present here some more interesting buffer overrun detections
 - such as off by one (mainly because the programmer did not count C's '
\backslash
0') or buffer overruns caused by integer arithmetics.
 These kind of overruns seems to be much more rare in the real sofware world,
 but Boa does cope well with these examples as can be seen by running Boa
 over the specific atomic test cases we have produced for such cases.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "boa"
options "acm"

\end_inset


\end_layout

\end_body
\end_document
